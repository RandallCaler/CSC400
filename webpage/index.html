<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="icon" type="image/x-icon" href="penguin.png">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Manchot: 3D Penguin Platformer</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <header>
        <div class="bubble">
            <h1>Manchot</h1>
            <p>3D Penguin Platformer</p>
        </div>
    </header>

    <nav style="padding: 10px;">
        <a href="#section8" onclick="flashSection('section8')">Intro</a>
        <a href="#section4" onclick="flashSection('section4')">Development</a>
        <a href="#game-preview" onclick="flashSection('game-preview')">Overview</a>
        <a href="#section0" onclick="flashSection('section0')">Level Editor</a>
        <a href="#section1" onclick="flashSection('section1')">Animation</a>
        <a href="#section2" onclick="flashSection('section2')">Sound Manager</a>
        <a href="#section3" onclick="flashSection('section3')">Collisions</a>
        <a href="#section5" onclick="flashSection('section5')">Graphics Tech.</a>
        <a href="#section6" onclick="flashSection('section6')">Team Members</a>
        <a href="#section7" onclick="flashSection('section7')">References</a>
    </nav>

    <section id="section8">
        <h2>Introduction</h2>
        <p>
            Welcome to Manchot's First Flight, a semi open world, 3D platforming game made by a team of eight Cal Poly students that uses graphical technologies
            and custom made mechanics. On this site, we will walk you through the development process and what technologies we used for the game.
        </p>
    </section>

    <section id="section4">
        <h2>Development</h2>
        <p>
            When brainstorming the project, we wanted to make an interactive product that was fun and enjoyable while utilizing various technologies and graphics components
            As such, making a small video game seemed appropriate and gave us the oppurtunity to be creative in its development. We began with starting the level editor, spearheaded by Hugh, Will, and Josh, and player controller
            which was overlooked by Nidhi, Claire, and Randall, as the basis components for our game. The team settled on a 3D platformer as we felt that could merge various technologies easily while allowing us to use simple but effective game design.
            We envisioned 3D movement in a fully modeled world plane and thus, it was critical to have the player controls feel intuitive. Further into development, we began the bigger tasks
            of collision, animation and sound, all while working on graphics technologies as well. Rand and Hugh focused, and fought with, the collisions, using bounding boxes for the geometry and interactions with the height map. 
            Will and Billy oversaw the modeling and animations for the titular penguin and for the collectables. Srini, Nidhi, Randall worked on the deisgn of the map, including the layout of the map and general platforming sections.
            Claire and Josh worked on other technologies for the game. Claire overseeing audio and Josh working on the game manager that added a HUD and collectables counter to the game.
            Ultimately the product came out remarkably well, with everything living up to what we had envisioned.
        </p>
    </section>

    <section id="game-preview">
        <h2>Game Overview</h2>

        <video width="640" height="334" controls>
            <source src="videos/Manchot 2024-06-16 19-32-31.mp4" type="video/mp4">
        </video>
        <p>Survey of Manchot's First Flight and game mechanics.</p>

        <video width="640" height="334" controls>
            <source src="videos/Manchot 2024-06-16 19-33-56.mp4" type="video/mp4">
        </video>
        <p>Demonstration of gliding puzzle to reach a collectible.</p>

        <video width="640" height="334" controls>
            <source src="videos/Manchot 2024-06-16 19-36-09.mp4" type="video/mp4">
        </video>
        <p>Visualization of boids flocking behavior with multiple collectibles.</p>

        <video width="640" height="334" controls>
            <source src="videos/Manchot 2024-06-16 19-40-33.mp4" type="video/mp4">
        </video>
        <p>Navigating through our hidden, snowy maze in search of a collectible.</p>


    </section>

    <section id="section0">
        <h2>Level Editor</h2>
        <p>
            The Level Editor for this project utilizes several key technologies to create a robust and interactive tool for 3D modeling and scene management.
            Central to the interface is Dear ImGui, a popular immediate mode graphical user interface library, which is integrated with GLFW for window management and OpenGL for rendering.
            This combination allows for a responsive and efficient GUI that supports both keyboard and gamepad inputs.
            The Level Editor also leverages the C++17 filesystem library to dynamically search and load various mesh file formats,
            including OBJ, DAE, FBX, and GLB, enhancing flexibility in asset management.
            Additionally, the editor implements ImGui's advanced features such as tree nodes, input text, combo boxes,
            and sliders to facilitate detailed entity and mesh manipulation, offering a comprehensive toolset for developers to build and customize 3D environments effectively.
            Finally, the Level Editor utilizes a technique named "color picking," which enables cursor clicking selection of entities within the world which drastically
            optimizes the world design process.
        </p>
    </section>

    <section id="section1">
        <h2>Animation</h2>
        <h3>Creating</h3>

        <p>
            For this project, the models were both created and animated in the open-source software Blender 3D. To keep the models both simple and
            performance optimized, high-poly to low-poly baking was done in Substance Painter, where the models were also textured. The goal with 
            both the models and the animations was to add a playful tone to our game's world, and to make the player have fun with just the simple
            act of making the character move around on the screen. With just a simple set of animations we were able to bring Manchot to life just as we had
            originally envisioned.
        </p>

        <h3>Importing</h3>
        <p>
            Assimp simplifies the process of loading complex animated models by handling the intricacies of file parsing and scene graph construction.
            To render these animated models, the project utilizes custom vertex shaders tailored to handle skeletal animations.
            These shaders perform bone transformations directly on the GPU, efficiently calculating the vertex positions based on the bone matrices and weights provided by Assimp.
            This approach leverages parallel processing capabilities of modern GPUs, ensuring smooth and performant animation playback even for complex models.
            The decision to calculate vertex positions within the vertex shader not only optimizes performance but also maintains flexibility in rendering,
            as the vertex shader can be easily adjusted or extended to support additional effects or animation techniques.
            This integration of Assimp and custom shaders underscores the project's commitment to high-quality, real-time 3D graphics.
        </p>
    </section>

    <section id="section2">
        <h2>Sound Manager</h2>
        <p>
            For our project, we built a sound management system to track all in-game sound effects. To help implement this sound manager, we used the
            Mini Audio sound library, an audio playback and capture library for C and C++. With Mini Audio we were able to better configure and manage 
            multiple sound effects at once. This library also allowed us to better adapt our code for different operating systems. Our EventManager class works by polling for events and tracking the event history to ensure a seamless auditory
            experience. This sound manager is responsible for the background music, collectible sound effects, and walking sounds that you 
            hear throughout Manchot's First Flight.
        </p>
    </section>

    <section id="section3">
        <h2>Collisions</h2>
        <p>
            We implement two forms of collision: heightmap collision and oriented bounding box collision. Having generated the world mesh from a heightmap, 
            we can also detect collisions with it by sampling that heightmap. We recreate the polygon for a given player position and find the y-axis position 
            corresponding to the xz-coordinate position of the player on that polygon. This value is used to simulate smooth movement over the heightmap.
            <br></br>
            Our team initially explored axis-aligned bounding boxes (AABB) for collision with objects in the world. As our design resolved toward a world with 
            many climbable surfaces created in the level editor, we determined that AABB did not meet all our needs. On the foundations of Johnny Huynh's 
            tutorial-oriented "Separating Axis Theorem for Oriented Bounding Boxes", we learned how to detect whether two bounding boxes of any size or 
            orientation are intersecting each other<sup><a href="#cite1" onclick="flashSection('cite1')">[1]</a></sup>. We expanded on this by developing code 
            to identify which plane of a bounding box experienced a collision, logic flags to prompt different behavior when colliding with collectibles versus 
            obstacles, and physics to redirect the player's motion in response to obstacle collisions.
        </p>
    </section>

    <section id="section5" height="100">
        <h2>Graphics Technologies</h2>
        <button onclick="scrollToCell(0)">Cook Torrance BRDF/PBR</button>
        <button onclick="scrollToCell(1)">Shadow Mapping</button>
        <button onclick="scrollToCell(2)">Mirage Shader</button>
        <button onclick="scrollToCell(3)">Boids</button>
        <button onclick="scrollToCell(4)">Texture Blending</button>
        <button onclick="scrollToCell(5)">DuDv Mapping</button>
        <button onclick="scrollToCell(6)">Virtual Camera</button>
        <button onclick="scrollToCell(7)">View Frustum Culling</button>

        <div id="container" class="container">
            <div id="smartCell0" class="smartCell active">
                <h3>Cook Torrance BRDF/PBR </h3>
                <p>
                    A BRDF Model, or Bidirectional Reflective Distribution Function Model, is a manner in which to perform lighting computations such that the lighting looks more realistic than the standard Blinn-Phong model. It does so by performing more complex lighting calculations, based off of the Fresnel reflectance model, Lambert diffuse light model, as well as the Trowbridge Reitz normal distribution function. This model is considered an example PBR (physically based rendering), as the computations done are more realistic and similar to real life. This model is used as the shader for the tree on the main island.
                </p>
            </div>
            <div id="smartCell1" class="smartCell">
                <h3> Shadow Mapping </h3>
                <p>
                    We used two render passes in order to create and render shadows. The first render pass was used to create a depth map from the light's perspective, and the second render pass sampled from the texture created from the first render pass, using it to determine whether the current pixel being shaded would be in shade or not.
                </p>
            </div>
            <div id="smartCell2" class="smartCell">
                <h3> Mirage Shader </h3>
                <p>
                    Our mirage shader modifies values in the vertex shader in order to give the appearance that islands further away are moving, in the same manner that far away objects appear on especially hot days. This creates a mirage effect, adding additional visual interest to the scene. 
                </p>
            </div>
            <div id="smartCell3" class="smartCell">
                <h3>Boids</h3>
                <p>
                    When our player collects an item, the item is then added to a flock of boids that follow the player around. To implement
                    this naive flocking behavior we used a variety of forces<sup><a href="#cite2" onclick="flashSection('cite2')">[2]</a></sup>:
                    <ul>
                        <li>Separation force: In order to simulate collisions between boids (collectibles) we implemented a repulsive force that, if within a certain radius of another boid, propells the current boid backwards.</li>
                        <li>Following the Leader: In place of the traditional cohesive force that follows the group's center of mass, we implemented a force that points the boids in the general direction of the player's position.</li>
                        <li>Tangential force: To prevent odd behavior of gathering around the player, we integrated a tangential force to create orbital behavior for our boids.</li>
                    </ul>
                </p>
            </div>
            <div id="smartCell4" class="smartCell">
                <h3>Texture Blending</h3>
                <p>
                    Our underlying world mesh, once deformed according to a heightmap, then receives texturing according to several factors:
                    <ul>
                        <li>Height: The low basin of the heightmap represents water, so fragments near the y-axis minimum of the heightmap are shaded with a water texture and undergo further graphics effects to sell the impression of moving water.</li>
                        <li>Slope: The heightmap's fragment shader takes weighted samples of two different textures for each fragment above the basin. As the slope of a ground fragment increases, the "flat ground" texture is sampled less and the "cliff" texture is sampled more.</li>
                        <li>Region: Color on the heightmap is interpreted as a region indicator. These are stored in a VAO and are used during shading to determine which textures to sample from. Our implementation has snowy, sandy, and grassy regions.</li>
                    </ul>
                </p>
            </div>
            <div id="smartCell5" class="smartCell">
                <h3>DuDv Mapping</h3>
                <p>
                    DuDv maps are a kind of normal map that specifies distortions to apply to surface normals. We give our water a rippling effect by taking 
                    scrolling samples of a DuDv map in the fragment shader and using it to calculate new normals for Blinn-Phong reflection without actually 
                    distorting the mesh's geometry.
                </p>
            </div>
            <div id="smartCell6" class="smartCell">
                <h3>Virtual Camera</h3>
                <p>
                    Our virtual camera has two primary modes of operation: one for gameplay and one for navigating the level editor. The former gives the 
                    player no direct control over the virtual camera's movement. Rather, Pen the Penguin's position and orientation determine where the 
                    camera is placed. Typically the camera takes a position behind and slightly above Pen. If this would place it below the ground mesh, 
                    it is moved further up and rotates down to keep Pen in sight.
                    <br></br>
                    The level editor uses a freecam which follows the movement of the cursor for orientation and takes WASD+Space+Ctrl inputs for movement.
                </p>
            </div>
            <div id="smartCell7" class="smartCell">
                <h3>View Frustum Culling</h3>
                <p>
                    When in game mode, the view frustum for each frame is calculated near the beginning of the rendering process and objects entirely 
                    outside the frustum are culled individually, reducing the number of draw calls made to the GPU.
                </p>
            </div>
        </div>
    </section>

    <section id="section6">
        <h2>Team Members</h2>
        <p>
            Randall Caler, Srinivas Sundararaman, Hugh Garmany, Will Kang, Josh Levin, Claire Ogawa, Nidhi Raviprasad, Billy Woodward
        </p>
    </section>

    <section id="section7">
        <h2>References</h2>
        <p id="cite1">[1] J. Huynh, "Separating Axis Theorem for Oriented Bounding Boxes." Available: <a href="https://www.jkh.me/files/tutorials/Separating%20Axis%20Theorem%20for%20Oriented%20Bounding%20Boxes.pdf">https://www.jkh.me/files/tutorials/Separating%20Axis%20Theorem%20for%20Oriented%20Bounding%20Boxes.pdf</a>.</p>
        <p id="cite2">[2] C. Parker, "Boids Pseudocode" Available: <a href="http://www.kfish.org/boids/pseudocode.html">http://www.kfish.org/boids/pseudocode.html</a>.</p>
        <p id="cite3">[3] Graphics Compendium, "Chapter 71: Cook-Torrance" Available: <a href="https://graphicscompendium.com/references/cook-torrance">https://graphicscompendium.com/references/cook-torrance</a>.</p>
        <p id="cite4">[4] V. Gordan, “Computer Graphics Tutorial - PBR (Physically Based Rendering),” <cite>YouTube</cite>. Sep. 05, 2021. Available: <a href="https://www.youtube.com/watch?v=RRE-F57fbXw">https://www.youtube.com/watch?v=RRE-F57fbXw</a>.</p>

    </section>
    <script src="scripts.js"></script>
</body>
</html>
