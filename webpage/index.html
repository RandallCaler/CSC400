<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="icon" type="image/x-icon" href="penguin.png">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Manchot: 3D Penguin Platformer</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <header>
        <div class="bubble">
            <h1>Manchot</h1>
            <p>3D Penguin Platformer</p>
        </div>
    </header>

    <nav style="padding: 10px;">
        <a href="#section0" onclick="flashSection('section0')">Section 0</a>
        <a href="#section1" onclick="flashSection('section1')">Section 1</a>
        <a href="#section2" onclick="flashSection('section2')">Section 2</a>
        <a href="#section3" onclick="flashSection('section3')">Section 3</a>
        <a href="#section4" onclick="flashSection('section4')">Graphics Technologies</a>
        <a href="#section5" onclick="flashSection('section5')">Team Members</a>
        <a href="#section6" onclick="flashSection('section6')">References</a>
    </nav>

    <section id="section0">
        <h2>Section 0</h2>
        <p></p>
    </section>

    <section id="section1">
        <h2>Section 1</h2>
        <p></p>
    </section>

    <section id="section2">
        <h2>Section 2</h2>
        <p></p>
    </section>

    <section id="section3">
        <h2>Section 3</h2>
        <p></p>
    </section>
    
    <section id="section4" height="100">
        <h2>Graphics Technologies</h2>
        <button onclick="scrollToCell(0)">Tech 1</button>
        <button onclick="scrollToCell(1)">Tech 2</button>
        <button onclick="scrollToCell(2)">Tech 3</button>
        <button onclick="scrollToCell(3)">Tech 4</button>
        <button onclick="scrollToCell(4)">Texture Blending</button>
        <button onclick="scrollToCell(5)">DuDv Mapping</button>
        
        <div id="container" class="container">
            <div id="smartCell0" class="smartCell active">
                <h3>Level Editor</h3>
                <p>
                    The Level Editor for this project utilizes several key technologies to create a robust and interactive tool for 3D modeling and scene management. 
                    Central to the interface is Dear ImGui, a popular immediate mode graphical user interface library, which is integrated with GLFW for window management and OpenGL for rendering. 
                    This combination allows for a responsive and efficient GUI that supports both keyboard and gamepad inputs. 
                    The Level Editor also leverages the C++17 filesystem library to dynamically search and load various mesh file formats, 
                    including OBJ, DAE, FBX, and GLB, enhancing flexibility in asset management.
                    Additionally, the editor implements ImGui's advanced features such as tree nodes, input text, combo boxes, 
                    and sliders to facilitate detailed entity and mesh manipulation, offering a comprehensive toolset for developers to build and customize 3D environments effectively.
                </p>
            </div>
            <div id="smartCell1" class="smartCell">
                <p>
                </p>
            </div>
            <div id="smartCell2" class="smartCell">
                <p>
                </p>
            </div>
            <div id="smartCell3" class="smartCell">
                <h3>Animation</h3>
                <h4>Creating</h4>
                <h4>Importing</h4>
                <p>
                    Assimp simplifies the process of loading complex animated models by handling the intricacies of file parsing and scene graph construction. 
                    To render these animated models, the project utilizes custom vertex shaders tailored to handle skeletal animations. 
                    These shaders perform bone transformations directly on the GPU, efficiently calculating the vertex positions based on the bone matrices and weights provided by Assimp. 
                    This approach leverages parallel processing capabilities of modern GPUs, ensuring smooth and performant animation playback even for complex models. 
                    The decision to calculate vertex positions within the vertex shader not only optimizes performance but also maintains flexibility in rendering, 
                    as the vertex shader can be easily adjusted or extended to support additional effects or animation techniques. 
                    This integration of Assimp and custom shaders underscores the project's commitment to high-quality, real-time 3D graphics.
                </p>
            </div>
            <div id="smartCell4" class="smartCell">
                <h3>Texture Blending</h3>
                <p>
                    Our underlying world mesh, once deformed according to a heightmap, then receives texturing according to several factors:
                    <ul>
                        <li>Height: The low basin of the heightmap represents water, so fragments near the y-axis minimum of the heightmap are shaded with a water texture and undergo further graphics effects to sell the impression of moving water.</li>
                        <li>Slope: The heightmap's fragment shader takes weighted samples of two different textures for each fragment above the basin. As the slope of a ground fragment increases, the "flat ground" texture is sampled less and the "cliff" texture is sampled more.</li>
                        <li>Region: Color on the heightmap is interpreted as a region indicator. These are stored in a VAO and are used during shading to determine which textures to sample from. Our implementation has snowy, sandy, and grassy regions.</li>
                    </ul>
                </p>
            </div>
            <div id="smartCell5" class="smartCell">
                <h3>DuDv Mapping</h3>
                <p>
                    DuDv maps are a kind of normal map that specifies distortions to apply to surface normals. We scroll-sample a DuDv map when shading the water to alter surface normals for the fragment shader and achieve a rippling effect without distorting the mesh's geometry.
                </p>
            </div>
        </div>
    </section>

    <section id="section5">
        <h2>Team Members</h2>
        <p>
            Randall Caler, Srinivas Sundararaman, Hugh Garmany, Will Kang, Josh Levin, Claire Ogawa, Nidhi Raviprasad, Billy Woodward
        </p>
    </section>

    <section id="section6">
        <h2>References</h2>
        <p id="cite1">[1] J. Huynh, "Separating Axis Theorem for Oriented Bounding Boxes." Available: <a href="https://www.jkh.me/files/tutorials/Separating%20Axis%20Theorem%20for%20Oriented%20Bounding%20Boxes.pdf">https://www.jkh.me/files/tutorials/Separating%20Axis%20Theorem%20for%20Oriented%20Bounding%20Boxes.pdf</a>.</p>
    </section>
    <script src="scripts.js"></script>
</body>
</html>
